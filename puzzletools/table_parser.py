from bs4 import BeautifulSoup
from puzzletools.enumeration import EnumerationMeta
from itertools import count
import csv

class _Formatter:
    def __init__(self,fmt=None,fallback=None):
        if fmt is None:
            self.fmt={}
        else:
            self.fmt=fmt
        if fallback is None:
            self.fallback=lambda d: d
        else:
            self.fallback=fallback

    def __call__(self,col,data):
        if col in self.fmt:
            return self.fmt[col](data)
        else:
            return self.fallback(data)

class Table:

    def __init__(self):
        self.headers=[]
        self.data=[]

    def make_enumeration(self,name,fields,display_key=None):
        fieldfuncs=[self._fieldfunc(*f[1:]) for f in fields]
        classdict={
            'fields' : [f[0] for f in fields],
            'data' : [[f(r) for f in fieldfuncs] for r in self.data]
        }
        if display_key:
            classdict['display_key']=display_key
        return EnumerationMeta(name,(),classdict)

    @staticmethod
    def _fieldfunc(idx,fmt=lambda x: x):
        if callable(idx):
            return idx
        else:
            return lambda r,i=idx,f=fmt: f(r[i])

    def _getdata(row,index):
        try:
            return row[index]
        except IndexError:
            pass
        try:
            return next(index)
        except TypeError:
            pass
        raise TypeError('Expected index to be an integer or iterator')

    @staticmethod
    def from_soup(soup,fmt=None):
        formatter=_Formatter(fmt,lambda c: c.text.strip())
        table=Table()
        all_rows=soup.find_all('tr')
        if not all_rows:
            return table
        for elt in all_rows[0].find_all('th'):
            colspan=int(elt.attrs.get('colspan',1))
            for n in range(colspan):
                table.headers.append(elt.text)
        for row in all_rows:
            if not row.find('td'):
                continue
            cells=row.find_all(['td','th'])
            if cells:
                rowdata=[]
                table.data.append(rowdata)
                colcount=count()
                for cell in cells:
                    colspan=int(cell.attrs.get('colspan',1))
                    for _ in range(colspan):
                        n=next(colcount)
                        data=formatter(n,cell)
                        rowdata.append(data)
        return table

    @staticmethod
    def from_csv(data,fmt=None,headers=False):
        formatter=_Formatter(fmt)
        reader=csv.reader(data)
        table=Table()
        if headers:
            table.headers = next(reader)
        for row in reader:
            rowdata=[]
            table.data.append(rowdata)
            for n, cell in enumerate(row):
                item=formatter(n,cell)
                rowdata.append(item)
        return table

    @staticmethod
    def wikilink_list_format(cell):
        l = []
        for t in cell.find_all('a'):
            text=t.text.strip()
            if text:
                l.append(text)
        return l

def allow_none(f):
    def apply(n):
        try:
            return f(n)
        except ValueError:
            return None
    return apply

def parse_wikitable(data,tablenum=0,fmt=None):
    """
    Creates an enumeration from an HTML table generated by MediaWiki.  See
    ``enumerations_web.py`` for example uses.
    """
    soup=BeautifulSoup(data,'lxml')
    for t in soup.find_all(attrs={'style':'display:none;'}):
        t.decompose()
    for t in soup.find_all('sup',attrs={'class':'reference'}):
        t.decompose()
    elt=soup.find_all('table',class_='wikitable')[tablenum]
    return Table.from_soup(elt,fmt)
